proc user_input {} {

    expect "clic => "

    send "garbage\n"
    expect "clic => "
    send ". . ~. ~ .\n"
    expect "clic => "

    send "r\n"
    expect "clic => "

    send "help\n"
    expect "clic => "
    
    send "5\n"
    expect "clic => "
    
    send "p\n"
    expect "clic => "

    send "19\n"
    expect " : "
    send "\nr\n"
    expect " : "

    send "p\n"
    expect "clic => "

    send "r\n"
    expect "clic => "
    
    send "h\n"
    expect "clic => "
    
    send "a\n"
    expect "clic => "
    
    send "b\n"
    expect "clic => "
}

spawn ./clic gopher://bitreich.org
set running [user_input]
send "x\n"
expect eof


spawn sbcl
expect "* "

send "(require :sb-cover) (require :sb-bsd-sockets)\n"
expect "* "

send "(declaim (optimize sb-cover:store-coverage-data))\n"
expect "* "

send "(compile-file \"clic.lisp\")\n"
expect "* "

send "(load \"clic.fasl\")\n"
expect "* "

send "(setf *offline* t)\n"
expect "* "

send "(main)\n"
set running [user_input]
send "(pop *history*) (p) (r)\n"
expect "* "

send "19\n"
expect " : "
send "q\n"
expect "* "

send "(main)\n"
expect "clic => "

send "exit\n"
expect "* "


# add an argv to test argv parsing
send "(setf *posix-argv* '(\"sbcl\" \"gopher://bitreich.org/0/documents/bitreich-manifesto.md\"))\n"
expect "* "

send "(main)\n"
expect " : "
send "q\n"
expect "* "


# add an argv to test argv parsing
send "(setf *posix-argv* '(\"sbcl\" \"bitreich.org/1/usr/solene/\"))\n"
expect "* "
send "(main)\n"
expect "clic => "
send "q\n"
expect "* "


# add an argv to test argv parsing
send "(setf *posix-argv* '(\"sbcl\" \"bitreich.org:70/\"))\n"
expect "* "
send "(main)\n"
expect "clic => "
send "q\n"
expect "* "


send "(sb-cover:report \"report/\")\n"
expect "* "

send "(quit)\n"
expect eof
